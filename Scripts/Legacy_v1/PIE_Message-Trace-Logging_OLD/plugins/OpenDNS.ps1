#=====================================#
# LogRhythm Labs                      #
# OpenDNS SmartResponse               #
# matt . willems [at] logrhythm . com #
# v1.0  --  June 2016                 #
# V1.5  --  Jake Reynolds June 2017   #
#=====================================#

# Copyright 2017 LogRhythm Inc.   
# Licensed under the MIT License. See LICENSE file in the project root for full license information.

#***********************************************************
# Usage:
# .\opendns.ps1 <API Key> <command> <target> <alarmID>
# Commands:
#     query - Query the OpenDNS API for information about:
#         ip - IPv4 address
#         domain - Domain name in domain.tld format
#     block - Add target to OpenDNS Umbrella block list
#         domain - Domain name in sub.domain.tld or domain.tld format
#         URL - URL in typical format with or without full path
# API Keys: 
#     query - Generated from user settings when API access enabled
#     block - Generated by adding a LogRhythm integration in 
#         the OpenDNS control panel under System Settings -> Integrations
#***********************************************************

#Requires -Version 3.0

param (
    [string]$key,
    [string]$command,
    [string]$query,
    [int]$alarmid
)
#Ignore invalid SSL certification warning
add-type @"
    using System.Net;
    using System.Security.Cryptography.X509Certificates;
    public class TrustAllCertsPolicy : ICertificatePolicy {
        public bool CheckValidationResult(
            ServicePoint srvPoint, X509Certificate certificate,
            WebRequest request, int certificateProblem) {
            return true;
        }
    }
"@
[System.Net.ServicePointManager]::CertificatePolicy = New-Object TrustAllCertsPolicy

#URLs for various actions in the OpenDNS API
$tagurl = "https://investigate.api.umbrella.com/domains/categorization/$query`?showLabels"
$DNSurl = "https://investigate.api.umbrella.com/dnsdb/name/a/$query.json"
$IPurl = "https://investigate.api.umbrella.com/dnsdb/ip/a/$query.json"
$malip = "https://investigate.api.umbrella.com/ips/$query/latest_domains"
$blockurl = "https://s-platform.api.opendns.com/1.0/events?customerKey=$key"
$SecInfoUrl = "https://investigate.api.umbrella.com/security/name/$query.json"
$linkInfoUrl = "https://investigate.api.umbrella.com/links/name/$query.json"

#Get current date and format to match the API
$UtcTime = ((get-date).ToUniversalTime()).ToString("yyyy-MM-ddTHH:mm:ss.fZ")

#Intialize blank comment. This is appended to and eventually pushed to the alarm details if $alarmid is > 0
$comment = ""

#Print target domain and add the same to the alarm comment
Write-Host "Target: $query"
$comment = $comment + "Target: $query`n"

#Function to update the LogRhythm Alarm if specified.
function Update_alarm ($alarmid, $comment)
{
if ($alarmid -gt 0) {
    Write-Host "Updating LogRhythm Alarm ID: $alarmid"

    #Text to add as a comment, LogRhythm UserID (logrhythmadmin), recordstatus, privacy
    $update = "`'Comment: $comment`',$alarmid,-100,1,0"
    $server = "localhost"
    $database = "LogRhythm_Alarms"

    #Set up a new SQL connection
    $Connection = New-Object System.Data.SqlClient.SqlConnection
    $Connection.ConnectionString = "server='$Server';database='$Database';trusted_connection=true;"
    $Connection.Open();
    
    $cmd = $Connection.CreateCommand();
    $cmd.CommandText ="INSERT INTO LogRhythm_Alarms.dbo.AlarmHistory (Comments,AlarmID,PersonID,RecordStatus,IsPrivate) VALUES ($update)";
    $cmd.ExecuteNonQuery();
    $Connection.Close();

    }
}

#Data validation
if ($command -eq "query"){
    Write-Host "===================== Umbrella Investigate Query ====================="
    #if object looks like an IP, try to add an IP
    if ($query -match "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$"){
        $command = "query_ip"
    }
    #If object looks like a domain, try to add a domain
    elseif ($query -match "(?=^.{1,253}$)(^(((?!-)[a-zA-Z0-9-]{1,63}(?<!-))|((?!-)[a-zA-Z0-9-]{1,63}(?<!-)\.)+[a-zA-Z]{2,63})$)"){
        $command = "query_domain"
    }
    #If object isn't recognized, fail
    else {
        Write-Error "Invalid target input, exiting."
        exit 1
    }
}
elseif ($command -eq "block"){
    #if the object starts with a protocol (it's a URL), match out the hostname
    if ($query -match "^(\w){3,5}://") {
        $query -match "(?<=\w{3,5}://)[^\s/:]+" > null
        $domain = $matches[0]
        $json = @"
        {
            "alertTime" : "$UtcTime",
            "deviceId" : "877ee0bc-b6c4-4f51-923b-71399558e201",
            "deviceVersion" : "7.1.6",
            "dstDomain" : "$domain",
            "dstUrl" : "$query",
            "eventTime" : "$UtcTime",
            "protocolVersion" : "1.0a",
            "providerName" : "LogRhythm"
            }
"@
    }
    #if the object is a hostname pattern, add it as the domain and format as a URL 
    elseif ($query -match "(?=^.{1,253}$)(^(((?!-)[a-zA-Z0-9-]{1,63}(?<!-))|((?!-)[a-zA-Z0-9-]{1,63}(?<!-)\.)+[a-zA-Z]{2,63})$)") {
         $json = @"
         {
            "alertTime" : "$UtcTime",
            "deviceId" : "877ee0bc-b6c4-4f51-923b-71399558e201",
            "deviceVersion" : "7.1.6",
            "dstDomain" : "$query",
            "dstUrl" : "http://$query/",
            "eventTime" : "$UtcTime",
            "protocolVersion" : "1.0a",
            "providerName" : "LogRhythm"
            }
"@
    }
    else {
        #if the object isn't a URL and isn't a hostname, we don't know what to do
        Write-Host "Unrecognized target. Exiting."
        exit 1
        }

}
else {
    #if the command being executed isn't a query or block, we don't know what to do
    Write-Error "Invalid command, exiting."
    exit 1
}

#Write-Host "Command: $command`n"
Write-Host "`n"

if($command -eq "query_domain"){
    #get the domain tags from the API to see if it's malicious
    $result = Invoke-RestMethod -Headers @{'Authorization' = "Bearer $key"} -Uri $tagurl | ConvertTo-Json -Depth 4
    $newresult = $result | ConvertFrom-Json
    $score = $newresult.$query.status
    Write-Host "Score: $score (-1: Malicious, 1: Benign)"
    $comment = $comment + "Score: $score (-1: Malicious, 1: Benign)`n"
    
    #if it's malicious
    if ($score -eq -1){
        Write-Host "Malicious Domain"
        $comment = $comment + "Malicious Domain.`n"
        $cat = $newresult.$query.security_categories
        Write-Host "Category: $cat"
        $comment = $comment + "Category: $cat`n"

        #fetch Security metadata
        $result = Invoke-RestMethod -Headers @{'Authorization' = "Bearer $key"} -Uri $SecInfoUrl | ConvertTo-Json -Depth 4
        $newresult = $result | ConvertFrom-Json

        $attack = $newresult.attack
        Write-Host "Known Attacks: $attack"
        $comment = $comment + "Known Attacks: $attack`n"        

        $threat = $newresult.threat_type
        Write-Host "Threat Type: $threat"
        $comment = $comment + "Threat Type: $threat`n"        
        
        $dgaScore = $newresult.dga_score
        Write-Host "DGA Score: $dgaScore"
        $comment = $comment + "DGA Score: $dgaScore`n"        

        $pageRank = $newresult.pageRank
        Write-Host "Google Pagerank: $pageRank"
        $comment = $comment + "Google Pagerank: $pageRank`n"        

        $ipRep = $newresult.rip_score
        Write-Host "IP Reputation: $ipRep"
        $comment = $comment + "IP Reputation: $ipRep`n"        

        $prefixRep = $newresult.prefix_score
        Write-Host "Prefix Reputation: $prefixRep"
        $comment = $comment + "Prefix Reputation: $prefixRep`n"        

        $asnRep = $newresult.asn_score
        Write-Host "ASN Reputation: $asnRep"
        $comment = $comment + "ASN Reputation: $asnRep`n"        

        #call the API again to get the domain's fastflux and IPs
        $result = Invoke-RestMethod -Headers @{'Authorization' = "Bearer $key"} -Uri $dnsurl | ConvertTo-Json -Depth 4
        $newresult = $result | ConvertFrom-Json
        #fetch FastFlux Score
        $fastFluxBool = $newresult.features.ff_candidate
        Write-Host "FastFlux: $fastFluxBool"
        $comment = $comment + "FastFlux: $fastFluxBool`n"        
        
        $ip = $newresult.rrs_tf.rrs.rr
        Write-Host "IP: $ip"
        $comment = $comment + "IP: $ip`n"
        Update_alarm $alarmid $comment

        # call for related domains/links here
        $result = Invoke-RestMethod -Headers @{'Authorization' = "Bearer $key"} -Uri $linkInfoUrl | ConvertTo-Json -Depth 4
        $newresult = $result | ConvertFrom-Json
        foreach ($entry in $newresult.tb1) {
            $domainName = $entry[0]
            $domainScore = $entry[1]
            $relatedDomains = $relatedDomains + "$domainName ($domainScore)`n"
        }
		Write-Host "Related Domains (by score): $relatedDomains"
        $comment = $comment + "Related Domains (by score): $relatedDomains`n"
        }

    elseif ($score -eq 0){
        Write-Host "Uncategorized Domain"
        $comment = $comment + "Uncategorized Domain.`n"
        Update_alarm $alarmid $comment
        }
    elseif ($score -eq 1){
        Write-Host "Benign Domain"
        $comment = $comment + "Benign Domain.`n"
        $cat = $newresult.$query.content_categories
        if ($cat) {
            Write-Host "Category: $cat"
            $comment = $comment + "Category: $cat`n"
            }
        Update_alarm $alarmid $comment
        }
    else {
        Write-Host "Unrecognized output"
        $comment = $comment + "Unrecognized output.`n"
        Update_alarm $alarmid $comment
        exit 1
        }
    exit 0
    }

if($command -eq "query_ip"){
    $result = Invoke-RestMethod -Headers @{'Authorization' = "Bearer $key"} -Uri $ipurl | ConvertTo-Json -Depth 4
    $newresult = $result | ConvertFrom-Json
    $domains = $newresult.rrs.rr
    $domains = $domains[0..100] | Sort
    $total = $newresult.features.rr_count
    if ($domains) {
        Write-Host "Domains (First 100): $domains"
        $comment = $comment + "Domains (First 100): $domains`n"
        }

    $result = Invoke-RestMethod -Headers @{'Authorization' = "Bearer $key"} -Uri $malip | ConvertTo-Json -Depth 4
    $newresult = $result | ConvertFrom-Json
    $count = $newresult.count

    Write-Host "Malicious Count: $count, Total: $total"
    $comment = $comment + "Malicious Count: $count, Total: $total`n"
    if ($count -gt 0){
        $domain = $newresult.value.name
        Write-Host "Malicious Domain: $domain"
        $comment = $comment + "Malicious Domain: $domain`n"
        }
    Update_alarm $alarmid $comment
    exit 0
    }

elseif($command -eq "block") {
    Write-Host "Blocking $query"
    $result = Invoke-RestMethod -Headers @{"Content-Type" = "application/json"} -Uri $blockurl -Body $json -Method POST
    if($result -match "id=\w+"){
        Write-Host "Success."
        exit 0
        }
    else {
        Write-Error "Unexpected response from API. Exiting."
        exit 1
        }
    }
else {
    Write-Error "Unrecognized command. Exiting."
    exit 1
    }
